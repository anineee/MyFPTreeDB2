## 摘要
SCM的出现正在促使人们重新思考如何将存储系统做成一种内存和存储合并在一起的的单层体系结构。在这一背景下，一些研究已经研究了如何在SCM中设计持久树作为这些新系统的基本构建块。然而，这些树明显慢于基于DRAM的树，因为树对延迟敏感，并且SCM表现出比DRAM更高的延迟。在本文中，我们提出了一种新型的混合SCM-DRAM持久和并发B+-树，即指纹持久树（FPTree），其性能接近于基于DRAM的树。在这种新型的设计中，叶子节点保存在SCM中，而中间节点保存在DRAM中并在恢复时重建。FPTree使用指纹技术，该技术将平均的叶内的探测键数量限制为1个。此外，我们为FPTree提出了一种混合并发方案，该方案部分基于硬件事务内存。我们进行了全面的性能评估，并证明了FPTree的性能优于具有不同SCM延迟的最先进的持久树，最高可达8.2倍。此外，我们证明了FPTree在具有88个逻辑内核的机器上可以很好地扩展。最后我们将需要评估的树集成到memcached和数据库原型中。我们证明了，与使用完全瞬态数据结构相比，FPTree的性能开销几乎可以忽略不计，同时显著优于其他持久树。

## 1.介绍
在过去几年中，许多新型的内存技术迅速出现，这些内存技术都具有非易失性的附加特性。这些技术，包括相变内存、记忆电阻、自旋转移矩磁性随机存取存储器，都可以归到SCM下。SCM将传统存储介质的经济特性，容量和非易失性特性与DRAM的低延迟和字节寻址能力相结合。因此，SCM具有超越替代DRAM的潜力：它可以用作通用存储器，即同时作为主存和存储器。
	鉴于SCM的特性，理论上可以在SCM中保留数据结构，同时获得接近DRAM的性能。最近的研究已经证明了这种可能性，而且一些采用这种新型范式的新的系统开始出现。我们观察到传统的主存B树实现不能满足这种用例所需的一致性要求，故而在这篇文章中，我们研究了作为核心数据库结构之一的索引结构的设计。此外，虽然期望SCM延迟在DRAM的范围内，但仍较慢且不对称——写入明显慢于读取。我们认为，SCM和DRAM之间的这些性能上的差异意味着对先前成熟的主存B树实现所做的假设可能不再适用。因此，我们认为需要设计一种新颖的、持久化B树，它能利用SCM的功能特性，同时也能展现出传统瞬态B树相似的性能。
	设计持久化数据结构在保持数据一致性上存在着空前的挑战，因为SCM是通过易失性CPU缓存来访问的，而软件对于易失性CPU缓存基本没有控制权。一些工作提出了SCM优化的B树，如CDDS B树[24]、WBtree[8]和NV树[28]，但它们无法匹配优化的基于DRAM的B树的速度。此外，它们并不能解决我们在第2节中确定的所有SCM编程难题，特别是那些持久化内存泄漏和数据恢复的难题。
	为了克服这一缺点，本文提出了基于四种设计原则的指纹持久树（fptree），以实现基于近DRAM（near-DRAM-based）的数据结构性能：
#### （1）指纹技术。
  指纹是叶内键值的一字节哈希值，连续放置在叶子的第一个缓存行大小的片段中。FPTree使用带有叶内位图的未排序的叶子节点（在[8]中首次提出），这样的话，一次搜索过程就将在叶子节点的所有有效键值上做线性迭代。通过首先扫描指纹，在平均情况下，我们可以将叶内探测键的数量限制为一个，从而显著提高性能。
#### （2）选择性持久。
  这个想法是基于众所周知的原始数据（primary data）和非原始数据（non-primary data）之间的区别，原始数据的丢失是不可逆的，而非原始数据丢失后，可以根据原始数据重建。选择性持久将原始数据存储在SCM中，将非原始数据存储在DRAM中。应用到FPTree中，这就对应于将叶子节点存储在SCM中，将中间节点存储在DRAM中。因此，与完全瞬态树相比，在对树进行遍历时，FPTree只有在访问叶子节点时才需要较大的代价。
#### （3）选择性并发。
  这意味着对瞬态和持久部分采用不同的并发方案。基本上，FPTree使用硬件事务内存（HTM）来处理中间节点的并发性，使用细粒度锁来处理叶节点的并发性。选择性并发很好地解决了HTM和持久性原语的明显不兼容性，例如缓存行刷新指令。并发控制技术（如键范围锁定[14]和正交键值锁定[16]）与我们的工作正交，因为我们的关注重点在于物理操作的并发性。
#### （4）完整可靠的编程模型。
  我们可以确认出四个编程难点：数据一致性、部分写入、数据恢复和内存泄露，其中，数据恢复和内存泄漏在相关工作中还未得到完全解决。我们依赖于一个完整可靠的编程模型来解决所有这些编程的难题，这个编程模型包含持久化指针（Persistent Pointers）的使用，一个优化的、崩溃安全（crash-safe）的、持久的分配器，以及一个内存泄露方案。与现有的工作相反，这使我们在性能评估的过程中，将持久性内存分配所耗费的更高的代价考虑在内。
	我们实现了FPTree和两个最先进的持久树，即NV-Tree和wBTree。使用微基准测试，我们发现FPTree的性能优于NV-Tree和wBTree：当SCM延迟为90ns时，使用大小固定的键则最高可达2.6倍，使用大小可变的键则最高可达4.8倍；当SCM延迟为650ns时，使用大小固定的键则最高可达5.5倍，使用大小可变的键则最高可达8.2倍。FPTree实现了这些结果，同时将不到3％的数据保存在DRAM中。此外，我们还演示了FPTree如何在具有88个逻辑内核的机器上进行扩展，这些内核具有固定大小和可变大小的键。而且，我们证明了，FPTree恢复时间分别比90 ns和650 ns的SCM延迟下的完全重建时间快76.96倍和29.62倍。最后，我们将FPTree和NV-Tree、wBTree集成到memcached和数据库原型系统中。与完全瞬态树相比，结果表明，FPTree在memcached中使用微基准测试（mc-benchmark）时，仅产生2％的额外开销（overhead），并且其性能受网络限制。当在数据库原型上使用TATP基准测试时，在SCM延迟分别为160 ns和650 ns 的情况下，FPTree的性能额外开销（performance overhead）仅为8.7％和12.8％，而最先进的树所产生的额外开销则分别达到了39.6％和51.7％。
	本文的其余部分安排如下：第2节详述了我们的SCM编程模型，而第3节则研究了相关的工作。第4节介绍了我们的设计目标，描述了对我们十分有用的设计原则。然后，第5节解释了FPTree的基本操作。此后，我们将在第6节讨论我们的实验评估结果。最后，第7节总结了论文。
  
  ## 2.SCM编程模型
  ### 2.1 数据一致性
  在下文中，我们将讨论SCM编程难题，并详细说明如何使用我们的编程模型解决它们。SCM是通过一个长易失性链访问的，如图1所示，包括存储缓冲区，CPU缓存和内存控制器缓冲区，而软件对这个链中的每一个组成部分都几乎没有控制权。 SNIA [3]建议使用SCM感知文件系统管理SCM，该文件系统允许应用层使用mmap直接访问SCM，从而启用加载/存储语义。因此，没有软件的工作就无法保证SCM写入的顺序和耐用性。为了解决这个问题，我们使用类似于现有技术的持久性原语，即CLFLUSH，MFENCE，SFENCE和非时间写入。 CLFLUSH从缓存中清除缓存行并将其内容写回内存。
 ![图1 类x86-处理器中的易失性链][图1]
当发出MFENCE时，所有等待的加载和存储内存操作在程序进一步进行之前完成。对于非临时写入，它们绕过缓存并缓存在特殊缓冲区中，该缓冲区在满时或发出MFENCE时刷新。此外，硬件供应商已宣布增强SCM编程性能的新指令。例如，英特尔已经发布了CLFLUSHOPT（CLFLUSH的优化版本），PCOMMIT和缓存行写回（CLWB）指令[2]。发出PCOMMIT时，所有从缓存中逐出的挂起写入都将被置为持久的。与CLFLUSH相反，CLWB不会逐出高速缓存行，而只是将其写回，这可以在高速缓存行在写回之后不久重新使用时，从而显着提高性能。在这项工作中，我们假设存在一个函数Persist，它实现了使数据持久化的最有效方法。在我们的评估系统中，此函数可以对应于由两个MFENCE包装的CLFLUSH，因为只有MFENCE可以命令CLFLUSH [2]，或者非临时写入后跟MFENCE。

  ### 2.2 数据恢复
  当程序重新启动时，它会使用新的地址空间，使所有存储的虚拟指针无效。因此，需要一种允许在重启时恢复SCM中的数据的机制。我们建议使用持久指针，该指针包含该文件中的8字节文件ID和8字节偏移量。文件ID对应于由持久分配器创建并用作Arena来分配内存的文件。持久分配器提供持久性和易失性指针之间的双向转换。由于持久性指针在故障期间保持有效，因此它们用于在重新启动时刷新易失性指针。
  ### 2.3 内存泄露
  由于内存分配在SCM中是持久的，因此内存泄漏也会持久存在。因此，内存泄漏对SCM的影响比DRAM更深。例如，让我们考虑向量调整大小操作。第一步是分配一个新的更大的数组。然后，将旧数组复制到新数组中。最后，旧数组被释放。如果在分配新数组之后但在复制阶段结束之前发生崩溃，则持久分配器将记住它分配了新数组但数据结构不会，导致持久性内存泄漏。为了解决这个问题，我们修改了持久性内存分配器的接口，以便它引用一个必须属于调用分配器的持久数据结构的持久性指针。在分配的情况下，分配器持久地将返回的存储器的地址写入该持久指针。在解除分配的情况下，分配器持久地重置（即，设置为空）该持久性指针以传达解除分配已成功执行。如果在分配期间发生崩溃，则在恢复时，分配器将完成或回滚分配，并且数据结构将检查它用于分配的持久性指针。如果后者不为null，则数据结构将知道它已接收到内存。简而言之，发现内存泄漏的任务在分配器和数据结构之间分配。
  ### 2.4 部分写入
  由于对SCM的写入具有字粒度，因此可能发生部分写入。实际上，如果在写入大于支持的p-atomic写入大小的数据时发生故障，则无法保证写入的数据量。与并发意义上的原子形成对比，我们的意思是通过p原子在一个CPU周期中执行的写入，即，对部分写入问题免疫的写入。为了解决这个问题，我们使用可以原子方式写入的标志来指示更大的写操作是否已经完成。在这项工作中，我们假设只有8字节写入是p原子的。
 
[图1]:https://github.com/Bedmote/DB-Go-Go-Go/raw/master/%E7%B1%BBx86-%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E6%98%93%E5%A4%B1%E6%80%A7%E9%93%BE.png "图1 类x86-处理器中的易失性链"
