## 摘要
SCM的出现正在促使人们重新思考如何将存储系统做成一种内存和存储合并在一起的的单层体系结构。在这一背景下，一些研究已经研究了如何在SCM中设计持久树作为这些新系统的基本构建块。然而，这些树明显慢于基于DRAM的树，因为树对延迟敏感，并且SCM表现出比DRAM更高的延迟。在本文中，我们提出了一种新型的混合SCM-DRAM持久和并发B+-树，即指纹持久树（FPTree），其性能接近于基于DRAM的树。在这种新型的设计中，叶子节点保存在SCM中，而中间节点保存在DRAM中并在恢复时重建。FPTree使用指纹技术，该技术将平均的叶内的探测键数量限制为1个。此外，我们为FPTree提出了一种混合并发方案，该方案部分基于硬件事务内存。我们进行了全面的性能评估，并证明了FPTree的性能优于具有不同SCM延迟的最先进的持久树，最高可达8.2倍。此外，我们证明了FPTree在具有88个逻辑内核的机器上可以很好地扩展。最后我们将需要评估的树集成到memcached和数据库原型中。我们证明了，与使用完全瞬态数据结构相比，FPTree的性能开销几乎可以忽略不计，同时显著优于其他持久树。

## 1.介绍
在过去几年中，许多新型的内存技术迅速出现，这些内存技术都具有非易失性的附加特性。这些技术，包括相变内存、记忆电阻、自旋转移矩磁性随机存取存储器，都可以归到SCM下。SCM将传统存储介质的经济特性，容量和非易失性特性与DRAM的低延迟和字节寻址能力相结合。因此，SCM具有超越替代DRAM的潜力：它可以用作通用存储器，即同时作为主存和存储器。
	鉴于SCM的特性，理论上可以在SCM中保留数据结构，同时获得接近DRAM的性能。最近的研究已经证明了这种可能性，而且一些采用这种新型范式的新的系统开始出现。我们观察到传统的主存B树实现不能满足这种用例所需的一致性要求，故而在这篇文章中，我们研究了作为核心数据库结构之一的索引结构的设计。此外，虽然期望SCM延迟在DRAM的范围内，但仍较慢且不对称——写入明显慢于读取。我们认为，SCM和DRAM之间的这些性能上的差异意味着对先前成熟的主存B树实现所做的假设可能不再适用。因此，我们认为需要设计一种新颖的、持久化B树，它能利用SCM的功能特性，同时也能展现出传统瞬态B树相似的性能。
	设计持久化数据结构在保持数据一致性上存在着空前的挑战，因为SCM是通过易失性CPU缓存来访问的，而软件对于易失性CPU缓存基本没有控制权。一些工作提出了SCM优化的B树，如CDDS B树[24]、WBtree[8]和NV树[28]，但它们无法匹配优化的基于DRAM的B树的速度。此外，它们并不能解决我们在第2节中确定的所有SCM编程难题，特别是那些持久化内存泄漏和数据恢复的难题。
	为了克服这一缺点，本文提出了基于四种设计原则的指纹持久树（fptree），以实现基于近DRAM（near-DRAM-based）的数据结构性能：
#### （1）指纹技术。
  指纹是叶内键值的一字节哈希值，连续放置在叶子的第一个缓存行大小的片段中。FPTree使用带有叶内位图的未排序的叶子节点（在[8]中首次提出），这样的话，一次搜索过程就将在叶子节点的所有有效键值上做线性迭代。通过首先扫描指纹，在平均情况下，我们可以将叶内探测键的数量限制为一个，从而显著提高性能。
#### （2）选择性持久。
  这个想法是基于众所周知的原始数据（primary data）和非原始数据（non-primary data）之间的区别，原始数据的丢失是不可逆的，而非原始数据丢失后，可以根据原始数据重建。选择性持久将原始数据存储在SCM中，将非原始数据存储在DRAM中。应用到FPTree中，这就对应于将叶子节点存储在SCM中，将中间节点存储在DRAM中。因此，与完全瞬态树相比，在对树进行遍历时，FPTree只有在访问叶子节点时才需要较大的代价。
#### （3）选择性并发。
  这意味着对瞬态和持久部分采用不同的并发方案。基本上，FPTree使用硬件事务内存（HTM）来处理中间节点的并发性，使用细粒度锁来处理叶节点的并发性。选择性并发很好地解决了HTM和持久性原语的明显不兼容性，例如缓存行刷新指令。并发控制技术（如键范围锁定[14]和正交键值锁定[16]）与我们的工作正交，因为我们的关注重点在于物理操作的并发性。
#### （4）完整可靠的编程模型。
  我们可以确认出四个编程难点：数据一致性、部分写入、数据恢复和内存泄露，其中，数据恢复和内存泄漏在相关工作中还未得到完全解决。我们依赖于一个完整可靠的编程模型来解决所有这些编程的难题，这个编程模型包含持久化指针（Persistent Pointers）的使用，一个优化的、崩溃安全（crash-safe）的、持久的分配器，以及一个内存泄露方案。与现有的工作相反，这使我们在性能评估的过程中，将持久性内存分配所耗费的更高的代价考虑在内。
	我们实现了FPTree和两个最先进的持久树，即NV-Tree和wBTree。使用微基准测试，我们发现FPTree的性能优于NV-Tree和wBTree：当SCM延迟为90ns时，使用大小固定的键则最高可达2.6倍，使用大小可变的键则最高可达4.8倍；当SCM延迟为650ns时，使用大小固定的键则最高可达5.5倍，使用大小可变的键则最高可达8.2倍。FPTree实现了这些结果，同时将不到3％的数据保存在DRAM中。此外，我们还演示了FPTree如何在具有88个逻辑内核的机器上进行扩展，这些内核具有固定大小和可变大小的键。而且，我们证明了，FPTree恢复时间分别比90 ns和650 ns的SCM延迟下的完全重建时间快76.96倍和29.62倍。最后，我们将FPTree和NV-Tree、wBTree集成到memcached和数据库原型系统中。与完全瞬态树相比，结果表明，FPTree在memcached中使用微基准测试（mc-benchmark）时，仅产生2％的额外开销（overhead），并且其性能受网络限制。当在数据库原型上使用TATP基准测试时，在SCM延迟分别为160 ns和650 ns 的情况下，FPTree的性能额外开销（performance overhead）仅为8.7％和12.8％，而最先进的树所产生的额外开销则分别达到了39.6％和51.7％。
	本文的其余部分安排如下：第2节详述了我们的SCM编程模型，而第3节则研究了相关的工作。第4节介绍了我们的设计目标，描述了对我们十分有用的设计原则。然后，第5节解释了FPTree的基本操作。此后，我们将在第6节讨论我们的实验评估结果。最后，第7节总结了论文。
  
  ## 2.SCM编程模型
  ### 2.1 数据一致性
  在下文中，我们将讨论SCM编程难题，并详细说明如何使用我们的编程模型解决它们。SCM是通过一个长易失性链访问的，如图1所示，包括存储缓冲区，CPU缓存和内存控制器缓冲区，而软件对这个链中的每一个组成部分都几乎没有控制权。 SNIA [3]建议使用SCM感知文件系统管理SCM，该文件系统允许应用层使用mmap直接访问SCM，从而启用加载/存储语义。因此，没有软件的工作就无法保证SCM写入的顺序和耐用性。为了解决这个问题，我们使用类似于现有技术的持久性原语，即CLFLUSH，MFENCE，SFENCE和非时间写入。 CLFLUSH从缓存中清除缓存行并将其内容写回内存。
 ![图1 类x86-处理器中的易失性链][图1]
当发出MFENCE时，所有等待的加载和存储内存操作在程序进一步进行之前完成。对于非临时写入，它们绕过缓存并缓存在特殊缓冲区中，该缓冲区在满时或发出MFENCE时刷新。此外，硬件供应商已宣布增强SCM编程性能的新指令。例如，英特尔已经发布了CLFLUSHOPT（CLFLUSH的优化版本），PCOMMIT和缓存行写回（CLWB）指令[2]。发出PCOMMIT时，所有从缓存中逐出的挂起写入都将被置为持久的。与CLFLUSH相反，CLWB不会逐出高速缓存行，而只是将其写回，这可以在高速缓存行在写回之后不久重新使用时，从而显着提高性能。在这项工作中，我们假设存在一个函数Persist，它实现了使数据持久化的最有效方法。在我们的评估系统中，此函数可以对应于由两个MFENCE包装的CLFLUSH，因为只有MFENCE可以命令CLFLUSH [2]，或者非临时写入后跟MFENCE。

  ### 2.2 数据恢复
  当程序重新启动时，它会使用新的地址空间，使所有存储的虚拟指针无效。因此，需要一种允许在重启时恢复SCM中的数据的机制。我们建议使用持久指针，该指针包含该文件中的8字节文件ID和8字节偏移量。文件ID对应于由持久分配器创建并用作Arena来分配内存的文件。持久分配器提供持久性和易失性指针之间的双向转换。由于持久性指针在故障期间保持有效，因此它们用于在重新启动时刷新易失性指针。
  ### 2.3 内存泄露
  由于内存分配在SCM中是持久的，因此内存泄漏也会持久存在。因此，内存泄漏对SCM的影响比DRAM更深。例如，让我们考虑向量调整大小操作。第一步是分配一个新的更大的数组。然后，将旧数组复制到新数组中。最后，旧数组被释放。如果在分配新数组之后但在复制阶段结束之前发生崩溃，则持久分配器将记住它分配了新数组但数据结构不会，导致持久性内存泄漏。为了解决这个问题，我们修改了持久性内存分配器的接口，以便它引用一个必须属于调用分配器的持久数据结构的持久性指针。在分配的情况下，分配器持久地将返回的存储器的地址写入该持久指针。在解除分配的情况下，分配器持久地重置（即，设置为空）该持久性指针以传达解除分配已成功执行。如果在分配期间发生崩溃，则在恢复时，分配器将完成或回滚分配，并且数据结构将检查它用于分配的持久性指针。如果后者不为null，则数据结构将知道它已接收到内存。简而言之，发现内存泄漏的任务在分配器和数据结构之间分配。
  ### 2.4 部分写入
  由于对SCM的写入具有字粒度，因此可能发生部分写入。实际上，如果在写入大于支持的p-atomic写入大小的数据时发生故障，则无法保证写入的数据量。与并发意义上的原子形成对比，我们的意思是通过p原子在一个CPU周期中执行的写入，即，对部分写入问题免疫的写入。为了解决这个问题，我们使用可以原子方式写入的标志来指示更大的写操作是否已经完成。在这项工作中，我们假设只有8字节写入是p原子的。
  
  ## 3.相关工作
  ### 3.1 持久化树
传统上，数据结构使用undo-redo日志记录和阴影技术来保留。闪存的兴起导致了新的优化数据结构的出现，例如Bw-Tree [19]。但是，这些仍然与日志记录和分页机制有着内在的联系，SCM可以完全不用这些机制。事实上，SCM的出现使得设计持久数据结构的技术更加新颖，更细粒度，但它提出了前所未有的挑战，如第2节所述。一些工作提出了应对这些挑战的全球解决方案，如NVHeap [10]，Mnemosyne [26]和REWIND [7]，它们基于垃圾收集和软件事务存储器。然而，这些解决方案由于系统记录变化的数据而产生额外的开销，这增加了由SCM的较高延迟引起的开销。另一项工作依赖于CPU提供的持久性原语，即内存屏障，缓存行刷新指令和非临时存储，以设计存储在SCM中并直接从SCM访问的持久数据结构。  
在此背景下，Venkataraman等人[24]提出了CDDS B-Tree，一种持久且并发的B-Tree，它依赖于版本控制来实现一致性。它通过检索最新一致版本的版本号并删除在该版本之后所做的更改来从故障中恢复。然而，它的可伸缩性受到使用全局版本号的影响，并且它需要垃圾收集来删除旧版本。陈 等人[8]建议使用带有位图的未分类节点来减少对SCM的昂贵写入次数。他们通过提出写原子B-Tree（wBTree）[9]来扩展他们的工作，这是一个依赖于位图的原子更新以实现一致性的持久树，以及用于更复杂操作（如拆分）的undo-redo日志。它在节点中使用分类的间接槽阵列，以避免线性搜索并启用二进制搜索。继另一种方法之后，杨等人[28]提出了NV-Tree，一种基于CSB + -Tree的持久且并发的B-Tree [23]。他们提出在放松内部节点的同时强制执行叶节点的一致性，并在发生故障时重建它们。这种方法假定仅使用SCM配置，而我们提出的选择性持久性假设采用混合SCM-DRAM配置，仅在SCM中存储主数据，并将其余部分保留在DRAM中以实现更好的性能。 NV-Tree使内部节点在内存中保持连续，并使用未附加叶子和仅附加策略。这种设计意味着当叶父节点溢出时需要进行昂贵的重建，并导致高内存占用。  
虽然wBTree和NV-Tree的性能优于现有的持久树，包括CDDS B-Tree，但它们的性能仍然明显慢于完全瞬态对应物。此外，他们忘记了持久性内存泄漏的问题。实际上，wBTree和NV-Tree都不记录新分配或解除分配的叶子的内存引用，这使得这些分配容易发生持久性内存泄漏。此外，虽然NV-Tree可以通过使用偏移来检索其数据，但是wBTree没有详细说明如何恢复数据：它使用的volatile指针在重启后变为无效，使得数据恢复几乎不可行。我们提出的FPTree成功地解决了这些问题。  
### 3.2 其他的相关工作
Arulraj等[5]研究了不同的基于SCM的数据库架构和恢复策略。他们得出结论，使用就地更新是最佳方法，因为不需要重新加载主数据或在恢复时应用重做日志，因为事务更改在提交时是持久的。 Oukid等人[21]提出了一种新颖的数据库架构，其中数据存储在SCM中并直接从SCM访问，从而无需传统的日志记录机制。 Kimura [18]介绍了FOEDUS，这是一种新颖的数据库架构，旨在扩展许多内核和非常大的SCM容量。 FPTree可以是这种系统的构建块，因为它基于相同的架构假设。  
为了管理SCM，Condit等人[11]介绍了BPFS，一种在SCM上运行的高性能事务文件系统。 Nayaranan等人[20]提出了整个系统持久性，其中数据仅在使用系统的剩余能量的电源故障时刷新，但不考虑软件故障。赵 等人[30]提出了Kiln，一种持久的内存设计，它利用SCM提供持久的就地更新，而无需记录或写入时复制。但是，他们假设一个非易失性的最后一级缓存。一些工作使用SCM来优化OLTP持久性管理，主要是通过优化日志记录基础设施[13,22,27]。最后，其他工作集中在优化SCM上的数据库算法，如排序和连接，但没有利用SCM的非波动性[8,25]。

## 4.FPTree设计原则
我们为FPTree提出了以下设计目标：
1.**持久化**。 FPTree必须能够从任何软件崩溃或电源故障情况中自我恢复到一致状态。我们不涉及这项工作中的硬件故障。
2.**近DRAM性能**。 FPTree必须表现出与瞬态树相似的性能。
3.**强大的性能**。 FPTree的性能必须能够适应更高的SCM延迟。
4.**快速恢复**。 FPTree的恢复时间必须明显快于瞬态B + -Tree的完全重建。
5.**高可扩展性**。 FPTree应该实现一个强大的并发方案，可以在高度并发的情况下很好地扩展。
6.**可变大小的键支持**。 FPTree应该支持变量键（例如字符串），这是许多系统的要求。  
图2描绘了FPTree的中间节点和叶节点布局。由于中间节点保存在DRAM中，因此它们具有带有排序键的经典主存储器结构。然而，叶子节点保持键值未排序并使用位图来跟踪有效条目，以减少昂贵的SCM写入次数，如Chen等人[8]首先提出的那样。此外，叶节点包含指纹，详见第4.2节。叶子中的下一个指针用于形成链接列表，其主要目标是：（1）启用范围查询，以及（2）允许在恢复期间遍历所有叶子以重建内部节点。下一个指针需要是持久指针才能在故障期间保持有效。最后，在每个叶子中使用一个字节的字段作为锁。在下文中，我们提出了我们提出的设计原则，使我们能够实现上述设计目标。
### 4.1 选择性持久化
选择性持久性可以描述为在SCM中保留最小的主数据集，在该数据集上将集中所有实现一致性的实现工作，并且重建在恢复时放置在DRAM中的所有非主数据。应用于B+树，如图3所示，叶节点使用持久链表放置在SCM中，而中间节点放在DRAM中，只要叶子处于一致状态就可以重建。因此，与瞬态B+树相比，仅访问叶子更昂贵。此外，中间节点仅代表B+树总大小的一小部分。因此，选择性持久性应该使我们的持久树具有与瞬态B+树类似的性能，同时仅使用DRAM的最小的一部分。我们的方法与NV-Tree [28]的基础硬件假设不同：我们假设混合SCM-DRAM配置，而NV-Tree采用仅SCM配置。  
简而言之，中间节点将保持经典结构并完全驻留在DRAM中而无需任何特殊的实现工作，而叶节点将完全驻留在SCM中并需要特别小心以确保它们的一致性。 SCM和DRAM之间的这种相互作用对于我们在4.4节中提出的并发机制至关重要。
### 4.2 指纹技术
未分类的叶子需要在SCM中进行昂贵的线性扫描。为了实现更好的性能，我们提出了一种称为指纹识别的技术。指纹是叶子键值（leaf keys）的单字节散列（哈希），在叶子的开头连续存储，如图2所示。通过在搜索过程中首先扫描它们，指纹就像一个过滤器一样，可以避免探测那些与搜索键的指纹不匹配的键。在下文中，我们表明，从理论上讲，指纹识别可以实现比wBTree和NV-Tree更好的性能。我们只考虑单一键（unique keys）的情况，这在实践中通常是可接受的假设[15]。我们证明，使用指纹识别，在一次成功的搜索过程中，叶内键探测次数的期望值等于1。在下面我们计算这个期望值。我们假设哈希函数生成均匀分布的指纹。设m是叶子中的条目数，n是可能的哈希值的数量（对于单字节指纹，n = 256）。（其余部分未翻译）
### 4.3 分摊的永久内存分配
由于持久性分配很昂贵，因此在拆分期间分配新的叶对于持久性树的总体性能来说是昂贵的。为了解决这个问题，我们建议通过同时分配多个叶块来分摊这些分配的开销。如图5所示，叶通过两个结构进行管理：
•当前分配的叶组的链接列表；
•目前游离且未在树中使用的挥发性叶片阵列。
获取和释放树叶有两种方法：
•GetLeaf：如果自由叶的向量不为空，则弹出最后一个元素并返回。如果它是空的，我们分配一个新的叶组，将它附加到组的链接列表中，并将它的叶添加到自由叶的向量中，除了返回的叶。
•FreeLeaf：当叶片被释放时，它被推入自由叶的向量中。如果其对应的叶组是完全空闲的，则释放它。
使用叶组可以减少昂贵的持久内存分配的数量，从而获得更好的插入性能，如第6.2节所示。
### 4.4 选择性并发
事务性内存是一种工具，它通过使用事务使一批写操作原子化地可见来简化并发性。HTM是硬件支持的事务性内存。一些硬件供应商提供HTM，如IBM on Blue Gene/Q和Power8处理器，以及Intel with Transactional Synchronization Extensions（TSX）。虽然我们在这项工作中使用了IntelTSX，但是我们的算法对于当前任何可用的HTM实现都是有效的。
  从程序员的角度来看，HTM被用作关键部分周围的粗粒度锁，但从硬件的角度来看，它表现为细粒度锁：在缓存线的粒度上检测事务之间的冲突。对于TSX，使用Xbegin和Xend指令将关键代码放入事务中。当线程到达Xbegin指令时，首先读取相应的锁，如果该锁可用，则在不获取该锁的情况下启动事务。如果事务成功，也就是说，如果事务在未检测到任何冲突的情况下到达xend指令，则原子提交将使事务内部所做的所有更改对其他线程原子可见。如果事务中止，则放弃所有缓冲的更改，并按照程序员定义的回退机制重新执行该操作。在我们的实现中，我们使用Intel线程构建Block1推测性自旋互斥体，它使用全局锁作为回退机制。
  为了检测冲突，每个事务都将读写集保存在一级缓存中。读取集包含事务读取的所有内存缓存线，写入集包含事务写入的所有内存缓存线。如果一个事务从另一个事务的写入集读取或写入另一个事务的读取或写入集，硬件就会检测到冲突。发生这种情况时，两个事务中的一个将被中止。在这种情况下，中止的事务返回到程序员定义的并发机制。为了提高性能，允许事务在使用返回机制之前重试几次。这是一个乐观的并发方案，因为它在这样的假设下工作：只有很少的冲突会发生，事务将以很高的概率执行无锁。
  HTM在当前体系结构中通过使用一级缓存监控更改来实现。因此，影响缓存的CPU指令（如clflush）被检测为冲突，如果在读或写集内执行，则会触发事务中止。标准B+树基于HTM的锁省略的一个简单实现是在HTM事务中执行其基本操作[17]。但是，插入和删除操作需要刷新叶中修改过的记录，从而中止事务并获取全局锁。这意味着实际上所有的插入和删除操作都将被序列化。因此，一方面使用HTM与我们需要将数据刷新到持久内存中以确保一致性之间存在明显的不兼容性。为了解决这个问题，我们建议对数据的瞬时部分和持久部分使用不同的并发方案，同样我们对DRAM和SCM中存储的数据应用不同的一致性方案。我们将方法命名为选择性并发。
  如图6所示，选择性并发包括执行不涉及修改HTM事务内部持久性数据的工作，以及需要HTM事务外部持久性原语的工作。在我们的fptree中，树的遍历和对内部节点的更改只涉及瞬态数据。因此，这些操作是在HTM事务中执行的，因此可以防止在并发HTM事务中执行其他操作。对于不能在事务内部执行的其他操作，将使用细粒度锁。基本上，要修改的叶节点在HTM事务中的树遍历期间被锁定。在完成对临时部分的所有修改之后，将提交事务。然后在事务外部处理持久性部分的其余修改。最后，释放持久部分上的锁。第5节详细介绍了使用TSX执行基本操作。

## 5.基本操作
在这项工作中，我们实现了三种不同的持久树：
1. FPTree。它是单线程版本，实现选择性持久性、指纹、摊余分配和未排序的叶。
2. 并行FPTree。此版本实现选择性持久性、选择性并发性、指纹和未排序的叶。至于摊余分配，由于它们构成了一个中央同步点，我们发现它们阻碍了可伸缩性。因此，在这个版本中不使用它们。
3. PTree。它反映了FPTree的轻版本，只实现选择性持久性和未排序的叶。与FPTree和wBTree相反，它将键和值保存在单独的数组中，以便在线性扫描键时获得更好的数据位置。
  在下面，我们将讨论具有固定大小键的FPTree的基本操作，并解释如何从任何软件崩溃或电源故障场景中恢复到一致状态。附录C中的可变大小密钥也有类似的讨论。此外，附录B中解释了在FPTree的单线程版本中管理叶组的算法。在下面的内容中，推测锁表示启用了TSX的锁。因为叶锁只在TSX事务中使用，所以不需要使用原子来修改它们。事实上，如果许多线程尝试写入同一个锁（从而写入同一缓存行），那么只有一个线程会成功，其他线程会中止。
### 5.1 Find
由于搜索操作不会修改持久性数据，因此可以将它们完全包装在TSX事务中，以防止它们与其他线程的写入操作发生冲突。如果另一个线程写入执行查找的线程读取的位置，则事务将中止并重试，如果超过重试阈值，则最终获取全局锁。搜索操作仍然需要检查是否有任何非TSX锁（即叶锁），这些锁可能是由另一个线程执行TSX事务之外的更改时使用的。算法1显示查找操作的伪代码。
  并发查找将一直执行到成功为止，使其在中止时重试，这可能是因为目标叶被锁定或检测到冲突。推测性锁可以通过两种方式执行：只要没有达到TSX重试阈值，就用XBEGIN指令启动常规TSX事务，或者使用全局锁。
  事务中止的方式取决于当前的情况：如果启动了常规的TSX事务，XABORT指令将撤消所有更改（由于没有进行任何更改，因此此处不相关），并返回到XBEGIN指令。如果使用了全局锁，XABORT指令将不起作用。在这种情况下，while循环和continue指令扮演中止和重试的角色。到达叶后，如果尚未获取其锁，则在不获取叶锁的情况下执行对键的查找。如果另一个线程在搜索键期间获取叶锁，则会检测到冲突，并中止两个事务之一。
### 5.2 Insert
算法2给出了并发插入操作的伪代码。它遵循三个步骤：（1）在TSX事务中，遍历树以到达叶并锁定它，并且传递是否需要分裂的信息；（2）在TSX事务外部，应用对插入叶的更改：如果需要，则进行也分裂，并在叶中插入键值对。这些操作使用持久性原语，如果在TSX事务中使用，则会触发中止；（3）如果在步骤2中发生叶分裂，则会在第二个TSX事务中更新内部节点。这可以通过两种方式完成：如果在修改叶时叶没有分裂，则直接更新叶的父节点，或者重新遍历树。然后，通过将叶锁定设置为0来释放叶锁定。在算法2中可以注意到，由于内部节点没有锁，所以第二个事务不需要使用while循环。因此，不需要手动中止事务。
  当不需要对叶进行分裂时，键值对和指纹将写入各自的槽中并持久化。这些写入的顺序并不重要，因为只要位图没有更新，它们就不可见。因此，如果在写入密钥和值时发生崩溃，则不需要执行任何操作，并且该操作被视为未完成。然后，位图被p-atomically更新并持久化。简而言之，如果在保留位图之前发生错误，则不会插入键值对，否则操作将成功执行。在这两种情况下，都不需要采取任何措施。
  算法3表示叶拆分的伪代码。为了确保树在拆分过程中失败时的一致性，我们需要使用包含两个持久指针的微日志：一个指向要拆分的叶，表示PCurrentLeaf，另一个指向新分配的叶，表示PNewLeaf。基本上，并发FPTree包含由临时无锁队列索引的拆分和删除微日志数组。微日志由无锁队列提供，并在操作结束时返回。分割恢复函数如算法4所示。拆分操作首先将要拆分的叶的持久地址写入PCurrentLeaf。如果此时发生故障，我们只需要重置微日志，因为PNewLeaf仍然为空。然后，我们分配一个新的叶并向分配器提供一个对PNewLeaf的引用，它在返回之前将分配内存的地址保存在PNewLeaf中。如果此时发生崩溃，拆分恢复功能将检查PNewLeaf是否为空。如果是，它将重置微日志并返回。否则，它会检测到分配已完成，从而继续分裂操作。此后，分裂叶的内容被持续复制到新叶中。然后确定新的键鉴别器（分裂键），并相应地更新新叶的位图。如果在后两个步骤中发生崩溃，当检测到PNewLeaf不为空时，恢复函数只需重新执行它们。然后，将更新分裂叶的位图，并将分裂叶的下一个指针设置为指向新叶。后一次写入不需要是p-atomic，因为如果此时发生故障，恢复函数将从复制阶段开始重新进行分裂。最后，微日志被重置。
  ### 5.3 Delete
  删除的并发方案，其伪代码如算法5所示，与插入的方案非常相似。树的遍历总是在TSX事务内部完成，如果叶已经被另一个线程锁定，则会中止该事务。到达叶后，会出现三种情况：（1）叶中找不到要删除的键；（2）叶包含要删除的键和其他键；（3）叶仅包含要删除的键。
  在第一种情况下，我们只返回没有找到的密钥（算法5中没有指出）。在第二种情况下，类似于没有分裂的插入，叶被锁定，并提交TSX事务。在事务外部，与要删除的值相对应的位图位置设置为0并保持不变。然后，叶被解锁。如前所述，该操作具有碰撞安全性。在第三种情况下，将删除叶。因为不需要持久性原语，内部节点在TSX事务中被修改。基本上，对应于叶的键和指针从其父级中移除，可能触发进一步的内部节点修改。我们注意到，不需要锁定要删除的叶，因为在内部节点更新完成后，其他线程将无法访问它。唯一需要在TSX事务之外更新的节点是已删除叶的左邻居；它的下一个指针将更新为指向已删除叶的下一个叶。在提交事务之前，将检索并锁定此左邻居。最后，在事务外部，更新左邻居的下一个指针，释放其锁，释放已删除的叶。
  算法6显示了叶删除操作的伪代码。与叶分裂类似，叶删除需要一个微日志来确保一致性。它由两个持久指针组成，分别指向要删除的叶和其上一个叶的PCurrentLeaf和PPrevLeaf。删除叶的函数首先更新PCurrentLeaf并将其持久化。如果PCurrentLeaf等于叶的链接列表的头，则必须更新其头指针。如果此时发生崩溃，则删除恢复过程（如算法7所示）检测到PCurrentLeaf已设置，并且其本身或其下一个指针等于叶的链接列表的头，并相应地继续操作。如果要删除的叶不是叶的链接列表的头，则将更新并持久化PPrevLeaf。然后，将要删除的叶的前一个叶的下一个指针更新为指向后一个叶的下一个指针。如果此时发生崩溃，则删除恢复过程会检测到微日志已完全设置（即，两个指针都不为空），因此会重复后一个操作。此后，在这两种情况下，通过将PCurrentLeaf传递给分配器的deallocate函数来释放已删除的叶，该函数将其重置为空。如果此时发生崩溃，则删除恢复功能检测到PCurrentLeaf为空并重置微日志。最后，微日志被重置。
### 5.4 Update
算法8给出了更新操作的伪代码。虽然更新操作看起来像删除后插入操作，但实际上它更优化。实际上，更新操作依赖于这样一个事实：位图可以以p原子的方式更新，以同时反映插入和删除。这样做的好处是在更新期间保持叶大小不变，这使得只有在包含要更新的记录的叶已满时才需要进行叶分裂。至于恢复逻辑，它与插入完全相同，只有在叶拆分时才需要一个微日志来确保一致性
### 5.5 Recovery
算法9显示了并行FPTree恢复函数的伪代码。它首先通过测试状态位来检查树在初始化期间是否崩溃。然后，对于微日志数组中的每个micro日志，它执行leaf split或leaf delete recovery函数。然后，它通过遍历叶、重置它们的锁以及检索每个叶中最大的键来将其用作鉴别器键来重建内部节点。此步骤类似于在批量加载操作中如何构建内部节点。最后，重建了微日志的队列。
  请注意，微日志是缓存线对齐的。因此，可以使用内存屏障对未被其他写操作分隔的微日志进行背靠背写入，然后一起持久化。实际上，当两个写操作针对同一个缓存线时，第一个写操作保证不会迟于第二个写操作。
### 5.6 Variable-size keys
为了支持可变大小的键（例如字符串键），我们将内部节点中的键替换为指向键的虚拟指针，而叶节点中的键替换为指向键的持久指针。与固定大小的键相比，确保一致性不需要任何额外的微日志记录，尽管每个插入或删除操作分别涉及键的持久分配或释放。附录C详细阐述了可变大小密钥的FPTree基操作及其相应的恢复过程。

 
[图1]:https://github.com/Bedmote/DB-Go-Go-Go/raw/master/%E7%B1%BBx86-%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E6%98%93%E5%A4%B1%E6%80%A7%E9%93%BE.png "图1 类x86-处理器中的易失性链"
